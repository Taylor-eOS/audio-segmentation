import os
import re
from whis_timestamped import process_file

def parse_duration_from_filename(filename):
    """Extract duration from filename generated by splitter script"""
    match = re.search(r"_(\d+\.\d+)s\.wav$", filename)
    if match:
        return float(match.group(1))
    raise ValueError(f"Couldn't parse duration from filename: {filename}")

def adjust_timestamps(transcript, offset):
    """Adjust timestamps in transcript lines by given offset"""
    adjusted_lines = []
    for line in transcript.split('\n'):
        line = line.strip()
        if not line:
            continue
            
        # Match timestamp format [start - end]
        ts_match = re.match(r'^\[(\d+\.\d+)\s*-\s*(\d+\.\d+)\](.*)', line)
        if ts_match:
            start = float(ts_match.group(1)) + offset
            end = float(ts_match.group(2)) + offset
            text = ts_match.group(3).strip()
            adjusted_lines.append(f"[{start:.2f} - {end:.2f}] {text}")
        else:
            adjusted_lines.append(line)
    return '\n'.join(adjusted_lines)

def process_segments(output_dir="output_segments"):
    # Get sorted list of segment files
    segment_files = []
    for fname in os.listdir(output_dir):
        if fname.endswith(".wav") and fname.startswith("segment_"):
            try:
                # Extract segment number for sorting
                seg_num = int(fname.split("_")[1])
                segment_files.append((seg_num, fname))
            except (IndexError, ValueError):
                continue
                
    # Sort by segment number
    segment_files.sort(key=lambda x: x[0])
    
    cumulative_offset = 0.0
    full_transcript = []
    segment_durations = []
    
    # First pass to collect durations
    for seg_num, fname in segment_files:
        file_path = os.path.join(output_dir, fname)
        try:
            duration = parse_duration_from_filename(fname)
            segment_durations.append(duration)
        except (ValueError, OSError) as e:
            print(f"Skipping {fname}: {str(e)}")
            continue
    
    # Second pass for transcription with error handling
    for idx, (seg_num, fname) in enumerate(segment_files):
        file_path = os.path.join(output_dir, fname)
        try:
            print(f"Processing {fname}...")
            transcript = process_file(file_path)
            
            # Adjust timestamps based on previous segments' duration
            adjusted_transcript = adjust_timestamps(transcript, cumulative_offset)
            full_transcript.append(adjusted_transcript)
            
            # Update offset with current segment's actual duration
            if idx < len(segment_durations):
                cumulative_offset += segment_durations[idx]
            else:
                # Fallback to filename parsing if duration list mismatched
                cumulative_offset += parse_duration_from_filename(fname)
                
        except Exception as e:
            print(f"Failed to process {fname}: {str(e)}")
            continue
    
    # Combine all transcripts
    combined = '\n\n'.join(full_transcript)
    
    # Save to file
    output_path = "combined_transcript.txt"
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(combined)
    
    print(f"Combined transcript saved to {output_path}")
    return combined

if __name__ == "__main__":
    process_segments()
